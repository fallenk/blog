# 动态规划

心得： **最优子问题解=>子问题循环得到当前状态；定义好状态；注意状态的有效值；当前状态只由之前的状态来确定。**

​	从一个最简单的例子去理解「动态规划」的基本思想。

​	首先我们解释「规划」这个词，在《算法导论》这本书里，对**「规划」的解释是「表格」**，这一点定义我觉得是非常准确的，因为可以用**「动态规划」解决的问题，就是让我们在求解问题的过程中，记录每一步求解的结果**。

​	「动态」这是与求解「动态规划」问题的两个思路相关的。

​	「动态规划」告诉我们求解一个问题，可以不直接求解这个问题，而是去**思考这个问题最开始（规模最小的时候）的时候是什么样子，然后通过递推的方式，一步一步得到结果，直到问题得到解决，这是一种「自下而上」的思想**。

​	而我们**熟悉的「递归」方法，是一种「自上而下」的思想**。这两种思想在绝大多数情况下，都能够帮助我们解决问题。而「动态」告诉我们「自上而下」「自下而上」都可以解决这一类问题。在这里给大家一个提示，在我们这门课程里介绍的**绝大多数「动态规划」的问题，都可以使用「自底向上」的思路解决**，树形 dp 等情况除外。

# **理解「重复子问题」**

### 1、重复子问题

也叫「重复子问题」，从「斐波拉契数列」求解的问题中，我们知道，如果**递归地去这个问题，会遇到很多「重复子问题」。这些子问题不应该被重复计算**。

### 2、最优子结构

**求解子问题得到的最优解，组成了规模更大的原问题的最优解**，这样的动态规划问题，我们称之为具有「最优子结构」。

动态规划问题通常应用的场景是：我们**直接求解这个问题感觉难度较大，但是我们把这个问题拆分为规模更小的问题的时候，这个问题的解通常也就能够找到**，这样的解决问题的实现通常都要**借助递归来实现**。

### 3、无后效性 只和前面的状态有关

- 在推导后面阶段的状态的时候，我们**只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的**。
- **某阶段状态一旦确定，就不受之后阶段的决策影响**。

我们将通过具体的例子来解释可以使用「动态规划」方法解决的问题的这 3 个特点。

我们先来看一个最最简单的问题：「斐波拉契数列」。

「力扣」第 509 题：[斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)。



### 方法一：使用递归

分析：虽然可以通过，但是认为是错的，因为进行了大量的重复计算。因此时间复杂度是认为指数级别。

Java 代码：  递归树

```java
class Solution {
    public int fib(int N) {
        if (N < 2) {
            return N;
        }
        return fib(N - 1) + fib(N - 2);
    }
}
```

解决的办法是使用一个数组作为「缓存」，在遇到同样的问题的时候，先查表。

- 如果已经计算过，就不再计算；
- 如果还没有计算过，就递归去计算一次。

Java 代码：

```java
import java.util.Arrays;

public class Solution {

    public int fib(int N) {
        if (N < 2) {
            return N;
        }

        // 0 要占一个位置，所以设置 N + 1 个位置
        int[] memo = new int[N + 1];
        Arrays.fill(memo, -1);
        return fib(N, memo);
    }

    public int fib(int n, int[] memo) {
        if (n == 0) {
            return 0;
        }

        if (n == 1) {
            return 1;
        }

        if (memo[n] == -1) {
            memo[n] = fib(n - 1) + fib(n - 2);
        }
        return memo[n];
    }
}
```

### 方法二：动态规划

上面「递归」求解的过程是「自底向上」的过程，而**「动态规划」告诉我们一种求解问题的思路：「自底向上」**，事实上，我们人在计算的时候，更多会这样去计算。



- 「自上而下」和 「自底向上」的解法通常都可以称为「动态规划」；
- 如果没有学习过「动态规划」，通过「递归」求解，应该需要知道做了大量重复计算，因此需要加入缓存，这种做法叫**「记忆化递归」或者「记忆化搜索」**；
- 而使用「自底向上」的思路可以解决在入门阶段的绝大多数「动态规划」问题，我们就是去想一下，这个问题最开始的时候是什么样子，而不是直接去解决这个问题，请大家在练习的过程中逐渐体会这个思路。

注意：并不是所有的「动态规划」问题都可以「自底向上」去做，但是初学的时候，大家可以直接适应这种解法，因为「自上而下」的写法就是「递归」的写法，我们已经相对熟悉。

```java
public class Solution {

    public int fib(int N) {
        if (N < 2) {
            return N;
        }
        int[] dp = new int[N + 1];

        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i < N + 1; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
}
```

这一小节，希望大家能够体会「动态规划」的一个思路，「自底向上」，并且理解使用「动态规划」解决问题的一个特征：「重复子问题」。

因为有「重复子问题」，我们在「自底向上」求解的过程中，通过先解决更小规模的问题，在处理更大规模的问题的时候，直接使用了更小规模问题的结果，进而原问题得到了解决。

# **理解「最优子结构」**

具体来说就是：问题的最优解参考了**子问题的最优解。**

这个提法比较学术，我们还是用具体的例子和大家解释。这道题是

## 例 1：[「力扣」第 322 题：零钱兑换](https://leetcode-cn.com/problems/coin-change/)

思路：

- 看题目的问法，只问最优值是多少，没有要我们求最优解，一般情况下就是「动态规划」可以解决的问题。
- 最优子结构其实比较明显，我们看示例 1：

```java
输入: coins = [1, 2, 5], amount = 11
```

凑成面值为 `11` 的最小硬币数可以由以下 3 者的最小值得到：

- 凑成面值为 `10` 的最小硬币数（假设已知） + 面值为 `1` 的这一枚硬币；
- 凑成面值为 `9` 的最小硬币数（假设已知） + 面值为 `2` 的这一枚硬币；
- 凑成面值为 `6` 的最小硬币数（假设已知） + 面值为 `5` 的这一枚硬币；

即 `dp[11] = min (dp[10] + 1, dp[9] + 1, dp[6] + 1)`。这就是这个问题的最优子结构，在三种选择中，选出一个最优解。

这里需要引入一个概念：状态。状态其实我们在「回溯算法」里介绍说。**状态在动态规划里其实含义是一样的，依然是表示我们求解一个问题进行到哪个阶段**，只不过表现这个变量不想「回溯算法」那么具体，很多时候，它是一个「概括值」。

我们这里直接把题目的问法设计成「状态」，有些问题不是这样的，我们后面再说。

#### 第 1 步：定义「状态」

`dp[i]`：凑齐总价值 `i` 需要的最少硬币数，状态就是问的问题。

#### 第 2 步：写出「状态转移方程」

所谓「状态转移方程」，其实就是「最优子结构」。

根据对具体例子的分析：

```
 dp[amount] = min(1 + dp[amount - coin[i]]) for i in [0, len - 1] if coin[i] <= amount
```

注意的是：

- 首先硬币的面值首先要**小于等于**当前要凑出来的面值；
- 剩余的那个面值应该要能够凑出来，例如：求 `dp[11]` 需要参考 `dp[10]` ，如果不能凑出来的话，`dp[10]` 应该等于一个不可能的值，可以设计为 `11 + 1`，也可以设计为 `-1` ，它们的区别只是在具体的代码编写细节上不一样而已。

再强调一次：**新状态的值要参考的值以前计算出来的「有效」状态值**。这一点在编码的时候需要特别注意。

因此，不妨先假设凑不出来，因为比的是小，所以初始化的时候应该设置为一个不可能的数。

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if (coins== null || coins.length == 0) {
            return -1;
        }
        
        int[] dp = new int[amount+1];
        Arrays.fill(dp, amount+1); 
        dp[0] = 0;
        for (int i =1; i<=amount; i++) {
            for(int coin : coins) {
                if (coin<=amount && i-coin>=0 && dp[i-coin] != amount+1){
                    dp[i] = Math.min(dp[i], dp[i-coin]+1);
                }
            }
        }
        if (dp[amount] == amount+1) {
            dp[amount] = -1;
        }
        return dp[amount];
    }
}
```

注意：

- 要求的是恰好填满，所以初始化的时候需要赋值为一个不可能的值：`amount + 1`。只有在有「正常值」的时候，「状态转移」才可以正常发生。

## 总结

可能有的朋友要问了，斐波拉契数列貌似没有「最优子结构」，事实上的确是这样，严格来说「斐波拉契数列」不是「动态规划」问题，但它却是理解「动态规划」问题的一个例子，主要是通过这个例子理解「动态规划」「自底向上」求解的思想和「重复子问题」的特征。大家先不要去纠结这件事情。

这节我们向大家介绍了「最优子结构」。希望大家能够体会，我们在**设计「状态」的时候，仅仅只是用一个数值表示了求解一个问题的阶段**，所以这个数值是一个「概括性」的数值，它不是具体解，但是它可以代表具体解。

这里要注意：对「状态」的定义一定要非常准确，在这里我的建议是，如果状态定义不是题目问的那个样子，把我们对状态的定义都作为注释写在代码里。

**只有「状态」定义准确，「状态转移方程」才会「准确」**。

其实求解这个问题，还利用到了一个「动态规划」问题的一个特点「无后效性」。我们在下一节向大家解释。

## 练习

### 练习 1：[「力扣」第 279 题：完全平方数](https://leetcode-cn.com/problems/perfect-squares/)中等

### 练习 2：[「力扣」第 343 题：整数拆分](https://leetcode-cn.com/problems/integer-break/)中等

- 题解：[“贪心选择”性质的简单证明、记忆化搜索、动态规划 （Python、Java）](https://leetcode-cn.com/problems/integer-break/solution/tan-xin-xuan-ze-xing-zhi-de-jian-dan-zheng-ming-py/)



# **理解「无后效性」**

「无后效性」的两层含义：

1. 在推导后面阶段的状态的时候，我们**只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的**。
2. 某阶段状态一旦确定，**就不受之后阶段的决策影响**。

## 例 1：[「力扣」第 198 题：打家劫舍](https://leetcode-cn.com/problems/house-robber/)中

这道问题是经典的「力扣」第 198 题：打家劫舍。题目只问最优值，并没有问最优解，因此绝大多数情况下可以考虑使用「动态规划」的方法。

如果我们直接将问题的问法定义成状态，会发现，当前这个房子「偷」和「不偷」会影响到后面的房子「偷」与「不偷」。

**一般的情况是，只要有约束，就可以增加一个维度消除这种约束带来的影响**，还是上一节和大家介绍的方法：把「状态」定义得清楚、准确，「状态转移方程」就容易得到了。

#### 第 1 步：设计状态

「状态」这个词可以理解为「记录了求解问题到了哪一个阶段」。

由于当前这一个房屋是否有两种选择：（1）偷；（2）不偷。

`dp[i][0]` 表示：考虑区间 `[0，i]` ，并且下标为 `i` 的这个房间偷，能够偷窃到的最高金额；

`dp[i][1]` 表示：考虑区间 `[0，i]` ，并且下标为 `i` 的这个房间不偷，能够偷窃到的最高金额。

说明：这个定义是**有前缀性质的，即当前的状态值考虑了（或者说综合了）之前的相关的状态值**，第 2 维保存了当前最优值的决策，这种**通过增加维度，消除后效性的操作在「动态规划」问题里是非常常见的**。

强调：

> 无后效性的理解：1、后面的决策不会影响到前面的决策； 2、之前的状态怎么来的并不重要。

再联系状态的定义：状态是一个概括的值，这个值是怎么来的，并不记录。因为状态定义更细致，后面的决策才不会影响到前面的决策。

#### 第 2 步：状态转移方程

**「状态转移方程」可以理解为「不同阶段之间的联系」**。

今天只和昨天的状态相关，依然是分类讨论：

- 下标为 `i` 的房屋不偷：或者是上一间不偷，或者是上一间偷，取二者最大值，即：`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])`；
- 下标为 `i` 的房屋偷：只需要从上一间不偷，这一间偷，即：`dp[i][1] = dp[i - 1][0] + nums[i]`。

#### 第 3 步：考虑初始化

**从第 2 天开始，每天的状态值只与前一天有关，因此第 1 天就只好老老实实算了**。好在不难判断：`dp[0][0] = 0` 与 `dp[0][1] = nums[0]`；

这里有一种**技巧，可以把状态数组多设置一行**，这样可以减少对第 1 天的初始化，这样的代码把第 1 天的情况考虑了进去，但编码的时候要注意状态数组下标的设置， 请见题解最后的「参考代码 3」。

#### 第 4 步：考虑输出

由于**状态值的定义是前缀性质的，因此最后一天的状态值就考虑了之前所有的天数的情况**。下标为 `len - 1` 这个房屋可以偷，也可以不偷，取二者最大值。

#### 第 5 步：考虑是否复用表格

由于我们只关心最后一个状态值。并且

**`dp[i]` 只参考了 `dp[i - 1]` 的值，状态可以压缩，可以使用「滚动数组」完成**。

值得说明的是：状态压缩的代码丢失了一定可读性，也会给编码增加一点点难度。

**参考代码 3**：使用「滚动数组」技巧，将空间优化到常数级别

在编码的时候，需要注意，只要访问到 `dp` 数组的时候，需要对下标 `% 2`，等价的写法是 `& 1`。

```java
public class Solution {

    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        if (len == 1) {
            return nums[0];
        }

        int[][] dp = new int[2][2];
        dp[0][0] = 0;
        dp[0][1] = nums[0];

        for (int i = 1; i < len; i++) {
            dp[i & 1][0] = Math.max(dp[(i - 1) & 1][0], dp[(i - 1) & 1][1]);
            dp[i & 1][1] = dp[(i - 1) & 1][0] + nums[i];
        }
        return Math.max(dp[(len - 1) & 1][0], dp[(len - 1) & 1][1]);
    }
}
```

## 总结



「状态」和「状态转移方程」得到以后，这个问题其实就得到了解决，剩下的一些细节的问题在编码的时候只要稍微留意一点就行了。

到这里「重复子问题」、「最优子结构」、「无后效性」我们就都向大家介绍完了。**「动态规划」告诉我们可以「自底向上」去考虑一件事情，并且记录下求解问题的中间过程**。

「动态规划」问题没有套路，我们只有通过不断地联系，去掌握状态设计的一般方法和技巧，体会上面所说的「动态规划」的基本概念和基本特征。



# 练习

### 练习 1：[「力扣」第 62 题：不同路径](https://leetcode-cn.com/problems/unique-paths/)中等

#### 方法一：动态规划

其实就是填写二维表格。

- 状态：`dp[i][j]` 表示走到坐标 `(i, j)` 的路径总数；
- 状态转移方程：思路依然是分类讨论，走到坐标 `(i, j)`  可以从上方下来，也可以从左边过来，路径总数是二者之和；





# 动态规划典型问题

## 练习 1：[「力扣」第 300 题：最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/description/)

- 题解：[动态规划 、优化（以贪心和二分作为子过程）](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/)

扩展问题：[「力扣」第 354 题：俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

- 题解：[贪心算法、二分查找（Python 代码、Java 代码）](https://leetcode-cn.com/problems/russian-doll-envelopes/solution/tan-xin-suan-fa-er-fen-cha-zhao-python-dai-ma-java/)

### 练习 2：[「力扣」第 1143 题：最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

- 题解：[动态规划](https://liweiwei1419.gitee.io/leetcode-algo/2018/05/14/leetcode-algo/1143-longest-common-subsequence/)

### 练习 3：[「力扣」第 53 题：最大子序和](https://leetcode-cn.com/problems/maximum-subarray)

- 题解：[动态规划、分治法](https://leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/)

### 练习 4：[「力扣」第 376 题：摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/) 

- 题解：[「力扣」第 376 题：摆动序列（动态规划）](https://blog.csdn.net/lw_power/article/details/103970211)

### 练习 5：[「力扣」第 72 题：编辑距离](https://leetcode-cn.com/problems/edit-distance/)

- 题解：[动态规划（Java）](https://leetcode-cn.com/problems/edit-distance/solution/dong-tai-gui-hua-java-by-liweiwei1419/)

### 练习 6：[「力扣」第 120 题：三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

- 题解：

### 练习 7：[「力扣」第 152 题：乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

- 题解：[二维动态规划](https://leetcode-cn.com/problems/maximum-product-subarray/solution/er-wei-dong-tai-gui-hua-by-liweiwei1419/)

### 练习 8：[「力扣」第 887 题：鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)

- 题解：[动态规划（只解释官方题解方法一）（Java）](https://leetcode-cn.com/problems/super-egg-drop/solution/dong-tai-gui-hua-zhi-jie-shi-guan-fang-ti-jie-fang/)